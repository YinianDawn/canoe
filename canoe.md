# Canoe程序设计



## 0 又一个编程语言

生活总是这般无趣，如果还找不到有点意思的东西，那么活着的意义又是什么呢。

前段时间花了大量时间构思，想要设计一条区块链出来。目前核心部分已经大致确定的，就差怎么去实现了。卡住的地方在于，智能合约怎么实现？第一步想到的，就是需要一个编程语言。已有的编程语言，几乎都能满足我想要图灵完备的要求。但有一个问题是，直接拿过来用，有点心理上抄袭的感觉，虽然说天底下什么东西不是抄的呢。其中一个比较重要的一点是，如果拿来编写智能合约，需要对代码进行入侵，其实也不对，如果虚拟机做的好，完全可以0入侵的方式运行智能合约。不过我想的更多，万一想让智能合约直接运行在物理机上呢？这种方式几乎没法对运行状态进行控制了。所以，不管怎样，一定是要编辑智能合约代码的。

既然要解析智能合约代码，那为啥不自己弄一个编程语言，加一些自己喜欢的语法糖呢。初生牛犊不怕虎啊，实际上一个新的编程语言的难度，和随便解析代码的难度不止一个数量级。但是，公链都是玩了，咋，编程语言不能玩？

最初我以为我能设计一个好的公链，比比特币以太坊都要好，但是现在我已经放弃了，现在我的想法是，不要比它们差就行了，主要是难度太大了。至于编程语言，反正都是这辈子要做的事情，我不做这个我做什么呢，那就现在做也一样，也算了却了一桩心愿了。估计会设计的很烂，也许永远都跑不起来，也许就算跑起来，也不适合编写任何应用。算了，谁在乎呢，反正我自己是不在乎的。

## 1 "元"

对象和函数的关系像是先有鸡还是先有蛋的问题。无解，本来嘛，这种哲学问题那么多哲学家都没解决，我想破头，也没搞出个合理的解释。所以，我不管了。

所谓元，我不知道怎么解释，所以我就不解释了，就取名为元得了。

```canoe
// 空元的定义为：
:{} :() {}

// 这3组符号说明的是这样一个东西
// :() 小括号里面的东西代表输入 这里是空的，说明这个元没有输入
// {} 花括号里面是一段代码
// 		小括号里的输入 => 执行代码 => 输出一个元
// 		这里其实是空的，所以没有代码，那么运行结果其实就是
//			:{} :() {}
//		惊不惊喜，意不意外，这是默认的嘛
// :{} 这个表明小括号输出的元必须符合这种约束，这种约束可以有“多个”

// 看不懂没关系
// 以后你会明白
// 其实我也不懂
```

## 2 元命名

会再次用到的东西，都应该有名字，如果连名字都没有，没法复用。

```canoe
null :{} :() {}
// 你看这个空元的名字就是null了
// 为了简介起见，想:{} :() {}这三个写了和没写一样，所以都可以省略喽

null
// 嗯，这就是个空元
```

## 3 元约束

如果这个世界只有这种"简单"的空元就好了，可惜！

```canoe
// 前面说 :{} 是对元的约束，其实是可以在里面写约束的，比如
null2 :{
	null
} :() {}

// 貌似这段代码不通过
// 因为我们要求{}执行过后会返回一个符合:{null}这种约束的元
// 上面我们说了 {} 返回的结果是 :{} :() {} 不太符合要求，应该这样
null2 :{
	null
} :() {
	return null2
}

// 这里面貌似有个逻辑bug，但是我也没办法了，想不出什么自圆其说的方式了
// 确切的说，如果不写 {} 那么 返回的结果就是 名字后面的定义本身

// 你只要知道 元可以有名字就好了，名字写在最前面，就这样
```

## 4 基本元

```canoe
// 计算机世界只有数字，没有元概念
// 为了连接 计算机世界和元世界 定义6个很单纯很不做作的元
// 计算机直接处理这6种类型的元 
// 其本身就相当于 :{} :() {}
int8 :int8 :() { return int8 } // 后面类似
int16
int32
int64
float32
float64

// 比如 整数和小数 
// 数字 1 是一个 int32元
// 小数 1.1 是一个 float64元
// 当使用数字或小数时，就是在使用这类的元

age => 18
// 相当于 age :int32 :() { return 18 }

salary => 8888.8
// 相当于 salary :float64 :() { return 8888.8 }

// 这里怎么就多了个符号 => 呢
// => 这个东西和元的命名差不多 即使不写也是一样的

// 希望我写到后面还是这样认为，这里先标记一下，搞不好要改这个=>的定义

```

## 5 元分类

```canoe
// 如果一个元不完全，就是动态元，否则就是静态的
// 默认省略的那种不叫不完全 null是完全自洽的
// 比如
age :int
// 定义个元，它有int元的特征，但是没有 :() 和 {} 这就有问题啊
// 按照省略的方式来看
age :int :() {}
// 这里{}应该返回一个符合int标准的元，但我们知道{}返回的是:{} :() {}
// 所以 age :int 就是不是省略的那种方式，那就是没有:() { ... }
// 所以这个是不完整的元，是动态元

// 所有以 => 命名方式指向的元，都必须是静态的
// 也就是说，如果没写完全，那就按默认的来
// 如果按默认的来不符合规则，那就不能放在 => 右边

age 18 
age => 18
age :int :() { return 18 }
// 这3个语句是一种东西，而且是静态元
```

## 6 对象元

```canoe
// 举个栗子
Person :{}               :() {}
Person :{ name :string } :() { return Person }
Person :{ name :string } :() 
Person :{ name :string } 
Person :{
	name :string
}
// 最后一个是经常用定义对象元的方式 但是 第2个才是标准的定义
Student :{}                         :() {}
Student :Person :{ school :string } :() { return Student }
Student :Person :{ school :string } :()
Student :Person :{ school :string }
Student :Person :{
	school :string 
}
// 这里定义了一个Student元 第2行看到，这个元有2个约束
// 1 是 Person  2 是{ school :string }
// 这种定义方式像是继承
Student :{
	name :string
	school :string 
}
// 和直接这样定义区别不是很大
```

## 7 函数元

```canoe
// 还有个栗子
add :{}  :()               {}
add :int :(x :int, y :int) { return x + y }
add(x :int, y :int) :int {
	return x + y
}
// 这下算是齐全了，:() 和 {} 都不是默认的了
// 这样解释，元add像是个什么呢，是个int，但是怎么得到这个int呢
// 必须要给add两个int元 x和y，然后add就会得到一个int元
// 比如
sum => add(1, 2)
// 这里我们应该明白 sum 应该是一个值为 3 的int元
// 通常会写成下面那种形式 
// 实际上这个编程语言还在我的想象之中，哪里来的通常？！

print :{} :()             {}
print :{} :(text :string) { ... }
print 	  :(text :string) { ... }
print(text :string) { 
	... 
}
// 这是没有返回约束的栗子 实际上没有返回约束就是返回 :{} :() {} 嘛
```



不行，复杂到我自己都受不了对象和函数，是没法统一的。go语言多好啊，简单。

随便搞一个go语言的子集算了，想要设计理念统一，没法子的，至少目前，用的这些概念，让人难以理解，这不是我想要的目的。将对象和函数统一，就省得传递的时候搞来搞去，但是目前状况同样过于复杂。还不如理解对象和函数简单。

所以，改，再改，要简单！！！

## 8 元空间

不可能把所有的要用到的元都写在一个文件里，既然要分开写，得有个方式引用其他文件中的元。另外，其他文件中的元允不允许被引用也是需要说明的。

这里定义2种范围来描述元的可见性

```canoe
:package	// 包内其他文件元可见 包定义为同属一个文件夹
			// 每一个元的默认级别
			// 没有子包的概念，每个文件夹就是一个包
					
:public		// 公开的 只要知道这个元那就可以用 
			// 文件元默认就是该范围 file_name.canoe
			// 在文件元file_name.canoe中实际上是这样
			// 1 file_name :public { 	
			// 2	  
			// 3 }
			// 行1和行3是默认存在，不用写出来，如果写出来那就是嵌套了
```

```canoe
│-- src  				// 所有代码文件位置
│   │-- test1           // 文件夹test1
│   │   │-- a.canoe     // 文件夹test1下的文件元a
│   │   │-- b.canoe     // 文件夹test1下的文件元b
│   │-- test2           // 文件夹test2
│   │   │-- a.canoe     // 文件夹test2下的文件元a
│   │-- main.canoe		// src文件下的文件元main

```

```canoe
// 文件夹test1下的文件元a
package test1
A :private 
B :package  // 默认级别 等同于 B 
C :protected 
D :public 
```

```canoe
// 文件夹test1下的文件元b
package test1
A :private 
B {
	a :test1.a.A  // error 
	b :test1.a.B  // right
} 
C :protected 
D :public 
```

```canoe
// 文件夹test2下的文件元a
package test2
A :private 
B  
C :protected 
D :public 
```

```canoe
// 文件夹src下的文件元main
// 如果不主动声明包 则默认包为 "" 即空串 没有

import test1	// 表明本文件元main有一个子元 test1
				// 该子元test1拥有a和b两个子文件元
import test1.a  // 表明本文件元main有一个子元 a
				// 该子元a即test1包下的文件元a
import test1.a.D // 表明本文件元main有一个子元 D
				 // 该子元D即test1包下的文件元a的子元D
				 
import test2.a  // error 已经有一个a，导入的元名称不能重复
import test2.a as t2a // 可以利用as起别名
import {
	test1
	t2a :test2.a
}

A :test1.a.D  // 导入的作用就是不用写全名称了
B :a.D 
C :D 

D // error D作为导入元 不可以重复

// 可见性
A1 :test1.a.A // error test1.a子元A可见性文件元私有
B1 :test1.a.B // error test1.a子元B可见性包私有
C1 :test1.a.C // error test1.a子元C可见性约束可见
C2 :test1.a // right 将test1.a当做约束，则C2可见test1.a.C
D1 :test1.a.D // 没问题

```

## 10 流程控制

```canoe

```

